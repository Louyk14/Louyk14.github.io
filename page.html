<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=gb2312" />
		<title>My first Three.js app</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body id="wf">
		<script src="js/three.js"></script>
		<script>
		var scene = new THREE.Scene();
		var cubeCamera = new THREE.CubeCamera( 1, 100000, 128 );
		var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
		scene.add(cubeCamera);

		var movedirection = 0;  

		//重力相关
			var jump_up_time = 99;
			var g = 0.000049;
			var jumping_time = [];
			var isJumping = [];
			var jump_dis = [];
			jumping_time.push(0);
			isJumping.push(false);
			var jumpTimer = null;


			for(var i = 0; i <= jump_up_time + 1; i++)
			{
				jump_dis.push(0);		
			}

			for(var i = jump_up_time; i >= 0; i--)
			{
				jump_dis[i] = 0.5 * g * (jump_up_time + 1 - i) * (jump_up_time + 1 - i) - jump_dis[i + 1];
			}

			function jumpMove()
			{
				if(isJumping[0] == true)
				{
					if(jumping_time[0] <= jump_up_time)
					{
						camera.translateY(jump_dis[jumping_time[0]]);
					}
					else
					{
						camera.translateY(-1 * jump_dis[2 * jump_up_time + 1 - jumping_time[0]]);
					}
					jumping_time[0]++;
					
					if(jumping_time[0] >= 2 * jump_up_time + 2)
					{
						isJumping[0] = false;
						jumping_time[0] = 0;
						clearInterval(jumpTimer);
					}
				}
			}

		//一些常量
			var mapsize = 20;
			var cube_side_length = 1;
			var cubes = [];
			var camera_step = 0.05;

		//图片、材料设置
			var grassmap = "grass.jpg";
			var grassTexture = THREE.ImageUtils.loadTexture(grassmap);
			var grassMatertial = new THREE.MeshBasicMaterial({map:grassTexture});

		//天空盒设置
			var skypic = "sky.jpg";
			var skypics = [skypic, skypic, skypic, skypic, skypic, skypic];
			var skyTextTure = THREE.ImageUtils.loadTextureCube(skypics);
			//skyTextTure.minFilter = THREE.LinearFilter;
			var shader = THREE.ShaderLib["cube"];
			shader.uniforms["tCube"].value = skyTextTure;
			var skyboxMaterial = new THREE.ShaderMaterial({
				uniforms: shader.uniforms,
				fragmentShader: shader.fragmentShader,
				vertexShader: shader.vertexShader,
				depthWrite: false,
				side: THREE.BackSide
			});
			var skyboxGeom = new THREE.BoxGeometry(500, 500, 500);
			skybox = new THREE.Mesh(skyboxGeom, skyboxMaterial);
			scene.add(skybox);


			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild(renderer.domElement);
			
			document.onkeydown=function(event){
	            var e = event || window.event || arguments.callee.caller.arguments[0];
	            
	            if(e && e.keyCode==38)
	            { // 上
	                movedirection = 1;
	            }
	            if(e && e.keyCode==40)
	            { //下
	                movedirection = 2;
	            }            
	            if(e && e.keyCode==37)
	            { // 左
	            	movedirection = 3;
	            }
	            if(e && e.keyCode==39)
	            { // 右
	                movedirection = 4;
	            }
	            if(e && e.keyCode==32)
	            { // 空格
	                if(isJumping[0] == false)
	                {
	                	jumping_time[0] = 0;
	                	isJumping[0] = true;
	                	jumpTimer = setInterval('jumpMove()', 10);
	                }
	            }
	         };

	         document.onkeyup=function(event){
	            var e = event || window.event || arguments.callee.caller.arguments[0];

	            if(e && (e.keyCode==38 || e.keyCode==40 || e.keyCode==37 || e.keyCode==39))
	            { // 上
	                movedirection = 0;
	            }
	        }

         	function init()
         	{
				var geometry = new THREE.BoxGeometry(cube_side_length, cube_side_length, cube_side_length);
         		var material = new THREE.MeshBasicMaterial({color: 0x00ff00});
         		var material_frame = new THREE.MeshBasicMaterial({color: 0x00ff00, wireframe: true, wireframeLinewidth: 2, vertexColors: 0x000000});

         		for(var i = 0; i < mapsize; i++)
				{
					for(var j = 0; j < mapsize; j++)
					{					
						/*var cube = new THREE.Mesh( geometry, material );
						scene.add(cube);
						cube.position.x = (j - (mapsize / 2)) * cube_side_length;
						cube.position.y = 0;
						cube.position.z = (i - (mapsize / 2)) * cube_side_length;*/

						var frame_cube = new THREE.Mesh( geometry, grassMatertial);
						scene.add(frame_cube);
						frame_cube.position.x = (j - (mapsize / 2)) * cube_side_length;
						frame_cube.position.y = 0;
						frame_cube.position.z = (i - (mapsize / 2)) * cube_side_length;
					}
				}
         	}

         	init();

			camera.position.z = 0;
			camera.position.y = 1;
			camera.position.x = 0;

			var mousepos = 0;

			document.getElementById('wf').onmousemove = function mouseMoveActor(event)
	        {
	        	var e = event || window.event;
	        	if((e.screenX - (screen.width / 2)) > 150)
	        	{
	        		mousepos = -1;
	        		//camera.rotation.y -= 0.01;
	        	}	
	        	else if((e.screenX - (screen.width / 2)) < -150)
	        	{
	        		mousepos = 1;
	        		//camera.rotation.y += 0.01;
	        	}     
	        	else
	        	{
	        		mousepos = 0;
	        	}   	
	        }

			var render = function () {
				//cubeCamera.position.copy(cube.position);
				//cubeCamera.updateCubeMap(renderer, scene);
				
				var direction = camera.getWorldDirection();
	            direction.multiplyScalar(camera_step);

				if(movedirection == 1)
				{
					camera.position.x += direction.x;
	                camera.position.z += direction.z;
				}
				else if(movedirection == 2)
				{
					camera.position.x -= direction.x;
	                camera.position.z -= direction.z;
				}
				else if(movedirection == 3)
				{
					direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 2);
	                camera.position.x += direction.x;
	                camera.position.z += direction.z;
				}
				else if(movedirection == 4)
				{
					direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), -Math.PI / 2);
	                camera.position.x += direction.x;
	                camera.position.z += direction.z;
				}
				camera.rotation.y += (0.01 * mousepos);
				if(Math.abs(Math.abs(camera.rotation.y) - 6.28) <= 0.005)
				{
					camera.rotation.y = 0;
				}
				requestAnimationFrame(render);
				renderer.render(scene, camera);
			};

			render();

		//2D地图
			function 2d_map_create()
			{
				for(var i = 0; i < 20; i++)
				{
					for(var j = 0; j < 20; j++)
					{
						var newDiv = document.createElement("div");
						newDiv.className = "mapgrid_style";
						newDiv.position = 'absolute';
						newDiv.style.cssText = ('width: 10px;
												height: 10px;
												border: 1px solid black;
												position: absolute;
												left: ' + i * 10 + 'px;
												top: ' + j * 10 + 'px;
												margin: 0px;
												padding: 0px;');
						document.body.appendChild(newDiv);
					}
				}
			}

			2d_map_create();
		</script>
		
	</body>
</html>