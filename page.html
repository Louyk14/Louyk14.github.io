<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=gb2312" />
		<title>My first Three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body id="wf">
		<script src="js/three.js"></script>
		<script>
		var scene = new THREE.Scene();
		var cubeCamera = new THREE.CubeCamera( 1, 100000, 128 );
		var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
		scene.add(cubeCamera);

		//重力相关
			var jump_up_time = 99;
			var g = 0.000049;
			var jumping_time = [];
			var isJumping = [];
			var jump_dis = [];
			jumping_time.push(0);
			isJumping.push(false);
			var jumpTimer = null;


			for(var i = 0; i <= jump_up_time + 1; i++)
			{
				jump_dis.push(0);		
			}

			for(var i = jump_up_time; i >= 0; i--)
			{
				jump_dis[i] = 0.5 * g * (jump_up_time + 1 - i) * (jump_up_time + 1 - i) - jump_dis[i + 1];
			}

			function jumpMove()
			{
				if(isJumping[0] == true)
				{
					if(jumping_time[0] <= jump_up_time)
					{
						camera.translateY(jump_dis[jumping_time[0]]);
					}
					else
					{
						camera.translateY(-1 * jump_dis[2 * jump_up_time + 1 - jumping_time[0]]);
					}
					jumping_time[0]++;
					
					if(jumping_time[0] >= 2 * jump_up_time + 2)
					{
						isJumping[0] = false;
						jumping_time[0] = 0;
						clearInterval(jumpTimer);
					}
				}
			}

		//一些常量
			var mapsize = 20;
			var cube_side_length = 1;
			var cubes = [];
			var camera_step = 0.05;

		//图片、材料设置
			var grassmap = "grass.jpg";
			var grassTexture = THREE.ImageUtils.loadTexture(grassmap);
			var grassMatertial = new THREE.MeshBasicMaterial({map:grassTexture});

		//天空盒设置
			var skypic = "sky.jpg";
			var skypics = [skypic, skypic, skypic, skypic, skypic, skypic];
			var skyTextTure = THREE.ImageUtils.loadTextureCube(skypics);
			//skyTextTure.minFilter = THREE.LinearFilter;
			var shader = THREE.ShaderLib["cube"];
			shader.uniforms["tCube"].value = skyTextTure;
			var skyboxMaterial = new THREE.ShaderMaterial({
				uniforms: shader.uniforms,
				fragmentShader: shader.fragmentShader,
				vertexShader: shader.vertexShader,
				depthWrite: false,
				side: THREE.BackSide
			});
			var skyboxGeom = new THREE.BoxGeometry(500, 500, 500);
			skybox = new THREE.Mesh(skyboxGeom, skyboxMaterial);
			scene.add(skybox);

			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild(renderer.domElement);
			
			document.onkeydown=function(event){
	            var e = event || window.event || arguments.callee.caller.arguments[0];
	            var direction = camera.getWorldDirection();
	            direction.multiplyScalar(camera_step);
	            console.log(direction);

	            if(e && e.keyCode==38)
	            { // 上
	                camera.translateX(direction.x);
	                camera.translateZ(direction.z);
	            }
	            if(e && e.keyCode==40)
	            { //下
	                camera.translateX(-1 * direction.x);
	                camera.translateZ(-1 * direction.z);   
	            }            
	            if(e && e.keyCode==37)
	            { // 左
	            	direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), -Math.PI / 2);
	                camera.translateX(direction.x);
	                camera.translateZ(direction.z);
	            }
	            if(e && e.keyCode==39)
	            { // 右
	                direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 2);
	                camera.translateX(direction.x);
	                camera.translateZ(direction.z);
	            }
	            if(e && e.keyCode==32)
	            { // 空格
	                if(isJumping[0] == false)
	                {
	                	jumping_time[0] = 0;
	                	isJumping[0] = true;
	                	jumpTimer = setInterval('jumpMove()', 10);
	                }
	            }
	         };

         	function init()
         	{
				var geometry = new THREE.BoxGeometry(cube_side_length, cube_side_length, cube_side_length);
         		var material = new THREE.MeshBasicMaterial({color: 0x00ff00});
         		var material_frame = new THREE.MeshBasicMaterial({color: 0x00ff00, wireframe: true, wireframeLinewidth: 2, vertexColors: 0x000000});

         		for(var i = 0; i < mapsize; i++)
				{
					for(var j = 0; j < mapsize; j++)
					{					
						/*var cube = new THREE.Mesh( geometry, material );
						scene.add(cube);
						cube.position.x = (j - (mapsize / 2)) * cube_side_length;
						cube.position.y = 0;
						cube.position.z = (i - (mapsize / 2)) * cube_side_length;*/

						var frame_cube = new THREE.Mesh( geometry, grassMatertial);
						scene.add(frame_cube);
						frame_cube.position.x = (j - (mapsize / 2)) * cube_side_length;
						frame_cube.position.y = 0;
						frame_cube.position.z = (i - (mapsize / 2)) * cube_side_length;
					}
				}
         	}

         	init();

			camera.position.z = 0;
			camera.position.y = 1;
			camera.position.x = 0;

			var mousepos = 0;

			document.getElementById('wf').onmousemove = function mouseMoveActor(event)
	        {
	        	var e = event || window.event;
	        	if((e.screenX - (screen.width / 2)) > 150)
	        	{
	        		mousepos = -1;
	        		//camera.rotation.y -= 0.01;
	        	}	
	        	else if((e.screenX - (screen.width / 2)) < -150)
	        	{
	        		mousepos = 1;
	        		//camera.rotation.y += 0.01;
	        	}     
	        	else
	        	{
	        		mousepos = 0;
	        	}   	
	        }

			var render = function () {
				//cubeCamera.position.copy(cube.position);
				//cubeCamera.updateCubeMap(renderer, scene);
				camera.rotation.y += (0.01 * mousepos);
				if(Math.abs(Math.abs(camera.rotation.y) - 6.28) <= 0.005)
				{
					camera.rotation.y = 0;
				}
				requestAnimationFrame(render);
				renderer.render(scene, camera);
			};

			render();
		</script>
	</body>
</html>